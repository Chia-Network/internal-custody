(mod
  (
    MOD_HASH
    RATE  ; mojos per second
    LAST_DRAIN
    INNER_PUZZLE
    current_time
    my_amount
    inner_solution
  )

  (include condition_codes.clib)
  (include curry_and_treehash.clib)
  (include sha256tree.clib)
  (include utility_macros.clib) ; or, assert, and

  (defun-inline coin_amount (condition) (f (r (r condition))))
  (defun-inline puzzle_hash (condition) (f (r condition)))

  (defun max (a b)
    (if (> a b)
      a
      b
    )
  )

  (defun-inline morph_singleton_condition
    (
      singleton_condition
      MOD_HASH
      RATE
      current_time
    )

    (c
      CREATE_COIN
      (c
        (puzzle_hash_of_curried_function MOD_HASH
          (puzzle_hash singleton_condition)
          (sha256 1 current_time)
          (sha256 1 RATE)
          (sha256 1 MOD_HASH)
        )
        (r (r singleton_condition))
      )
    )
  )


  (defun-inline assert_rate (possible_withdrawal_amount withdrawal_amount current_time)
    (assert
      (i withdrawal_amount (> possible_withdrawal_amount withdrawal_amount) ONE)
      (list ASSERT_SECONDS_ABSOLUTE current_time)
    )
  )

  (defun-inline calculate_possible_withdrawal (RATE LAST_HEIGHT current_time)
    (* RATE (- current_time LAST_HEIGHT))
  )

  (defun generate_final_conditions
    (
      singleton_condition
      remaining_conditions
      withdrawal_amount
      possible_withdrawal_amount
      MOD_HASH
      RATE
      current_time
    )

    (c
      (assert_rate possible_withdrawal_amount withdrawal_amount current_time)
      (c
        (morph_singleton_condition
          singleton_condition
          MOD_HASH
          RATE
          current_time
        )
        remaining_conditions
      )
    )
  )

  (defun found_singleton
    (
      singleton_condition
      remaining_conditions
      (
        MOD_HASH
        RATE
        LAST_DRAIN
        current_time
        my_amount
      )
    )

    (generate_final_conditions
      singleton_condition
      remaining_conditions
      (max (- my_amount (coin_amount singleton_condition)) 0)  ; adding value does not count for negative rate accounting
      (calculate_possible_withdrawal RATE LAST_DRAIN current_time)
      MOD_HASH
      RATE
      current_time
    )
  )

  (defun search_for_singleton (conditions found_function args)
    (if conditions
        (if (and
              (= (f (f conditions)) CREATE_COIN)      ; this is a CREATE_COIN
              (logand (coin_amount (f conditions)) 1) ; the amount is odd
            )
            (found_function (f conditions) (r conditions) args)
            (c
              (f conditions)
              (search_for_singleton (r conditions) found_function args)
            )
        )
        (x)
    )
  )

  ; main
  (c
    (list ASSERT_MY_AMOUNT my_amount)
    (search_for_singleton
      (a INNER_PUZZLE inner_solution)
      found_singleton
      (list
        MOD_HASH
        RATE
        LAST_DRAIN
        current_time
        my_amount
      )
    )
  )
)
