(mod
  (
    THIS_MOD_HASH
    ROOT
    STATE
    my_amount
    spend_type
    spend_solution
  )

  (include condition_codes.clib)
  (include curry_and_treehash.clib)
  (include sha256tree.clib)
  (include utility_macros.clib)
  (include merkle_utils.clib)

  ; STATE is a list with the following elements in order
  ; - REKEY_MOD_HASH
  ; - ACH_MOD_HASH
  ; - P2_SINGLETON_MOD_HASH
  (defun-inline REKEY_MOD_HASH (STATE) (f STATE))
  (defun-inline ACH_MOD_HASH (STATE) (f (r STATE)))
  (defun-inline P2_SINGLETON_MOD_HASH (STATE) (f (r (r STATE))))

  ;;; utility functions ;;;
  (defun calculate_our_ph (THIS_MOD_HASH ROOT STATE)
    (puzzle_hash_of_curried_function THIS_MOD_HASH
      (sha256tree STATE)
      (sha256 1 ROOT)
      (sha256 1 THIS_MOD_HASH)
    )
  )

  ; This function enforces only one create coin with a specifed puzzle hash and amount
  (defun enforce_one_specific_coin (conditions ph amt seen)
    (if conditions
        (c
          (f conditions)
          (enforce_one_specific_coin
            (r conditions)
            ph
            amt
            (if (= CREATE_COIN (f (f conditions)))
                (assert
                  (not seen)  ; not seen
                  (= ph (f (r (f conditions))))
                  (= amt (f (r (r (f conditions)))))
                  ; then
                  1
                )
                seen
            )
          )
        )
        (assert seen ())
    )
  )

  ;;; FINISH REKEY ;;;
  (defun-inline calculate_rekey_ph (REKEY_MOD_HASH ROOT new_root)
    (puzzle_hash_of_curried_function REKEY_MOD_HASH
      (sha256 1 ROOT)
      (sha256 1 new_root)
    )
  )
  (defun finish_rekey (THIS_MOD_HASH ROOT STATE my_amount (
    new_root
  ))
    (list
      (list ASSERT_PUZZLE_ANNOUNCEMENT
            (sha256
              (calculate_rekey_ph (REKEY_MOD_HASH STATE) ROOT new_root)
              new_root
            )
      )
      (list CREATE_PUZZLE_ANNOUNCEMENT 'r')
      (list CREATE_COIN
            (calculate_our_ph THIS_MOD_HASH new_root STATE)
            my_amount
      )
    )
  )

  ;;; LOCK ;;;
  (defun lock (THIS_MOD_HASH ROOT STATE my_amount (
    puzzle_reveal
    proof_of_inclusion
    new_root
    puzzle_solution
  ))
    (assert
      (= ROOT (calculate_merkle_root_for_merkle_proof (sha256tree puzzle_reveal) proof_of_inclusion))
      ; then
      (enforce_one_specific_coin
        (a puzzle_reveal puzzle_solution)
        (calculate_our_ph
          THIS_MOD_HASH
          new_root
          STATE
        )
        my_amount
        ()
      )
    )
  )

  ;;; START REKEY ;;;
  (defun start_rekey (THIS_MOD_HASH ROOT STATE my_amount (
    puzzle_reveal
    proof_of_inclusion
    new_root_after
    puzzle_solution
  ))
    (assert
      (= ROOT (calculate_merkle_root_for_merkle_proof (sha256tree puzzle_reveal) proof_of_inclusion))
      ; then
      (c
        (list CREATE_COIN (calculate_our_ph THIS_MOD_HASH ROOT STATE) my_amount)
        (enforce_one_specific_coin
          (a puzzle_reveal puzzle_solution)
          (calculate_rekey_ph (REKEY_MOD_HASH STATE) ROOT new_root_after)
          0
          ()
        )
      )
    )
  )

  ;;; WITHDRAW_PAYMENT ;;;
  (defun-inline calculate_ach_payment (ACH_MOD_HASH P2_SINGLETON_MOD_HASH p2_ph)
    (puzzle_hash_of_curried_function ACH_MOD_HASH
      (sha256 1 P2_SINGLETON_MOD_HASH)
      (sha256 1 p2_ph)
    )
  )
  (defun withdraw_payment (THIS_MOD_HASH ROOT STATE my_amount (
    puzzle_reveal
    proof_of_inclusion
    withdrawal_amount
    p2_ph
    puzzle_solution
  ))
    (assert
      (= ROOT (calculate_merkle_root_for_merkle_proof (sha256tree puzzle_reveal) proof_of_inclusion))
      (not (logand withdrawal_amount 1))
      ; then
      (c
        (list CREATE_COIN
            (calculate_our_ph THIS_MOD_HASH ROOT STATE)
            (- my_amount withdrawal_amount)
        )
        (enforce_one_specific_coin
          (a puzzle_reveal puzzle_solution)
          (calculate_ach_payment (ACH_MOD_HASH STATE) (P2_SINGLETON_MOD_HASH STATE) p2_ph)
          withdrawal_amount
          ()
        )
      )
    )
  )

  ;;; ACCEPT PAYMENT ;;;
  (defun accept_payment (THIS_MOD_HASH ROOT STATE my_amount (
    p2_parent
    p2_amount
  ))
    (list
      (list CREATE_PUZZLE_ANNOUNCEMENT (sha256 p2_parent (P2_SINGLETON_MOD_HASH STATE) p2_amount))
      (list ASSERT_COIN_ANNOUNCEMENT (sha256 (sha256 p2_parent (P2_SINGLETON_MOD_HASH STATE) p2_amount) '$'))
      (list CREATE_COIN (calculate_our_ph THIS_MOD_HASH ROOT STATE) (+ my_amount p2_amount))
    )
  )

  ; main
  (c (list ASSERT_MY_AMOUNT my_amount)
    (if (= spend_type 1)
        (finish_rekey THIS_MOD_HASH ROOT STATE my_amount spend_solution)
        (if (= spend_type 2)
            (lock THIS_MOD_HASH ROOT STATE my_amount spend_solution)
            (if (= spend_type 3)
                (start_rekey THIS_MOD_HASH ROOT STATE my_amount spend_solution)
                (if (= spend_type 4)
                    (withdraw_payment THIS_MOD_HASH ROOT STATE my_amount spend_solution)
                    (if (= spend_type 5)
                        (accept_payment THIS_MOD_HASH ROOT STATE my_amount spend_solution)
                        (x)
                    )
                )
            )
        )
    )
  )

)